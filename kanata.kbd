#|

Written by Chuck in 2024
https://bogorad.github.io/

Based on the brilliant Miryoku_kmonad => Kinesis layout
https://github.com/manna-harbour/miryoku_kmonad

With enourmous help from the author of Kanata
https://github.com/jtroo

This is my second attempt at Kanata configuration.
https://github.com/jtroo/kanata/

Reasons for choosing Kanata vs KMonad:
=========================
1. KMonad isn't friendly with the mouse.
2. KMonad can't do chords, and I need them
3. I like the idea of RUST better than HASKEL :)

https://github.com/bogorad/miryoku-kanata/blob/main/kanata.kbd

About layers:
=============
0. I closely follow the logic of Miryoku as applied to my Kinesis Advantage (KB500), only using 36 keys.

U_BASE is the default. I use COLEMAK-DH.
U_QWERTY - no key remapping, used for Cyrillic in Windows, with 2/3-taps for missing chars.
U_TAP has almost everything disabled (just U_NAV to be able to return to U_BASE); I don't use it, considering removal.
U_NUM has nubmers (basically, numpad+)
U_SYM - my own map. This is probably my strongest deviation from Miryoku, I didn't appreciate the idea of U_SYM being shifted U_NUM, so I stole someone's idea:
top row for shifted numbers,
the rest of the symbols in pairs, unshifted on bottom row, shifted on middle row.
U_FUN - for function and other seldom used keys
U_MOUSE - for mouse emulation and ENG/RUS switching. Although since I put Cyrillic layer on a countdown timer, I rarely use direct switching on this layer; considering its removal. Mouse follows U_NAV layer (see below).
U_BUTTON has buttons and HYPER-combos to be interpreted by the OS. Just starting.
U_NAV is heavily modified. Although I'm a 20+year Vim user, I find fascination with h/j/k/l quite silly. Consequently, I remapped directional keys in the w/a/s/d style, for the right hand (obviously; NAV key is uner my left thumb. Also moved PgUp/PgDn. Also added {[()]} heavily used in Vim navigation - also saving precious space on U_SYM layer. The only(?) two exceptions to the left/right-hand rule - the left/right keys on C/D so that when watching Youtube I can skip boring parts using my thumb+index fingers.
Put a lot of effort so that symbols send the same codes regardless of the input language (Cyrillic screws it up badly). Even had to create a special symbols layer for Cyrillic. Most are Unicode, but not all - my beloved ZTree is a console application and expects "real" keys.
Put comma, dot and question mark on chords.
Added chords for vim-save and vim-cmd.
Make heavy use of deffakekeys - for input-language + layer switching, timed-out.
In Windows, Hyper-keys are handled by MS PowerToys at the moment, considering a switch to Autohotkey.
Undo/Cut/Copy/Paste are chords on z/x/c/d/v.
Notable changes from Miryoku/Kinesis:
U_BASE:
1.1. Restored home-row mod-taps. To fix problems due to rolls, I use fork.
1.1.1. All keys in U_BASE are mapped to chords. Very easy to add new ones!
1.1.2. When a key is pressed, its code is passed to chords.
1.1.3. Chord decides if it's a single key (e.g., @met-a which is a/meta),
1.2. Added some chords
1.3. Got tired of unintentional 'enter' taps, assigned ret to a chord, disabled on kbd.

U_NAV
2.1. Changed direction keys: h/j/k/l with Colemak is just stupid.
2.2. Added [{()}] for VIM-style navigation
2.3. Moved CAPS and replaced it with CAPS-WORD
2.4. n/a
2.5. Threw away copy/cut/paste, used chords instead.
2.6. Moved home/end, pgup/pgdn.
2.7. n/a.
2.8. Not on this layer, but related to navigation: modified tab always resets the language to ENG.

U_MOUSE
3.1. Changed direction keys to match U_NAV.
3.2. Added language switching ENG/RUS, one more slot available; not much use any longer since Cyrillic is on a 5-second timeout
3.3. Moved scroll wheel buttons
3.4. This and U_MEDIA are the only two layers
where U_TAP/U_QWERTY/U_BASE switching is possible
3.5. Threw away copy/cut/paste, use chords in U_BASE nstead.
3.6. Assigned DELETE key to V, easy to reach when my right hand is on the mouse.

U_SYM was revised completely. Followed the advice
to keep !@#$%^&*() to use existing muscle memory.
Added more keys. Mapped / to \. TBD

The real lctl key on my keyboard is not used, but defined in defsrc so that my mouse's copy/paste keys work.


Here'a an empty layer declaration,
so we can copy+paste it and customize

(deflayer U_DUMMY
  ;; right half
  XX      XX      XX      XX      XX
  XX      XX      XX      XX      XX
  XX      XX      XX      XX      XX
  ;; thumbs
  XX              XX              XX
  ;; left half
  XX      XX      XX      XX      XX
  XX      XX      XX      XX      XX
  XX      XX      XX      XX      XX
  ;; thumbs
  XX              XX              XX
  ;; extra keys - not actually used, needed to intercept events
  XX
)

|#

;; config stuff
(defcfg
  process-unmapped-keys yes
  block-unmapped-keys yes
  danger-enable-cmd yes
  movemouse-inherit-accel-state yes
)

;; global variables
(defvar
  tap-timeout   200
  short-tap-timeout 120
  hold-timeout  300
  tt $tap-timeout
  st $short-tap-timeout
  ht $hold-timeout
)

;; we'll process only these keys
;;
;; using left and right halves of
;; the keyboard separately
(defsrc
  ;; left
  q       w       e       r       t
  a       s       d       f       g
  z       x       c       v       b
  bspc            del             end
  ;; right
  y       u       i       o       p
  h       j       k       l       ;
  n       m       ,       .       /
  pgdn            ent             spc
  ;; extra keys - not actually used, needed to intercept events
  ;; generated by my mouse
  lctrl
)

#|
This section is here because of the way Kanata processes
events. The idea is that FakeKeys make an action atomic,
so it can be serialized via (macro fake real whatever)
|#
(deffakekeys
  ;; win-input switching - add more here
  fake-win-eng (multi (release-key rctl) (release-key rmet) lalt lsft 0)
  fake-win-rus (multi (release-key rctl) (release-key rmet) lalt lsft 1)
  ;;
  ;; permanent layer-switching
  fake-lsw-bas (layer-switch U_BASE)
  fake-lsw-fun (layer-switch U_FUN)
  fake-lsw-nav (layer-switch U_NAV)
  fake-lsw-num (layer-switch U_NUM)
  fake-lsw-med (layer-switch U_MEDIA)
  fake-lsw-mou (layer-switch U_MOUSE)
  fake-lsw-qwe (layer-switch U_QWERTY)
  fake-lsw-tap (layer-switch U_TAP)
  fake-lsw-sym (layer-switch U_SYM)
  fake-lsw-sym-r (layer-switch U_SYM_RUS)
  ;;
  ;; symbols to be handled by OS
  fake-hyper-a (multi rmet rctl lalt a)
  fake-hyper-b (multi rmet rctl lalt b)
  fake-hyper-c (multi rmet rctl lalt c)
  fake-hyper-d (multi rmet rctl lalt d)
  fake-hyper-e (multi rmet rctl lalt e)
  fake-hyper-f (multi rmet rctl lalt f)
  fake-hyper-g (multi rmet rctl lalt g)
  fake-hyper-h (multi rmet rctl lalt h)
  fake-hyper-i (multi rmet rctl lalt i)
  fake-hyper-j (multi rmet rctl lalt j)
  fake-hyper-k (multi rmet rctl lalt k)
  ;;
  fake-lang-switch-eng (multi
    (on-press-fakekey fake-win-eng tap) ;; tell windows to switch layout.
    (on-press-fakekey fake-lsw-bas tap) ;; switch layer to U_BASE
  )
  fake-lang-switch-rus (multi
    (on-press-fakekey fake-win-rus tap) ;; tell windows to switch layout.
    (on-press-fakekey fake-lsw-qwe tap) ;; switch layer to U_QWERTY
    (on-idle-fakekey  fake-lang-switch-eng tap 5000) ;; back in 5 sec of inactivity
  )
)
;; shorter names for fake keys etc
(defalias
  ;; shorter names for layer switches
  lsw-bas (on-press-fakekey fake-lsw-bas tap)
  lsw-fun (on-press-fakekey fake-lsw-fun tap)
  lsw-nav (on-press-fakekey fake-lsw-nav tap)
  lsw-num (on-press-fakekey fake-lsw-num tap)
  lsw-med (on-press-fakekey fake-lsw-med tap)
  lsw-mou (on-press-fakekey fake-lsw-mou tap)
  lsw-qwe (on-press-fakekey fake-lsw-qwe tap)
  lsw-tap (on-press-fakekey fake-lsw-tap tap)
  lsw-sym (on-press-fakekey fake-lsw-sym tap)
  lsw-sym-r (on-press-fakekey fake-lsw-sym-r tap)
  ;; shorter names for input swithing in Windows
  eng (on-press-fakekey fake-lang-switch-eng tap)
  rus (on-press-fakekey fake-lang-switch-rus tap)
)

;; aliases - so we can use short labels in layer maps
(defalias
  ;; layer switching
  ;; temporary layer switching
  lwh-bas   (layer-while-held U_BASE)
  lwh-but   (layer-while-held U_BUTTON)
  lwh-fun   (layer-while-held U_FUN)
  lwh-nav   (layer-while-held U_NAV)
  lwh-num   (layer-while-held U_NUM)
  lwh-med   (layer-while-held U_MEDIA)
  lwh-mou   (layer-while-held U_MOUSE)
  lwh-sym   (layer-while-held U_SYM)
  lwh-sym-r (layer-while-held U_SYM_RUS)
  lwh-ctl   (layer-while-held U_CTL)
  ;;
  ;; swetch to English and then send tab
  eng-tab   (macro @eng 100 tab)
  ;; do eng-tab if any of right-side HRMs are active, tab otherwise
  smart-tab (fork tab @eng-tab (rsft lalt rctl rmet))
  ;;
  ;; tap-hold actions for thumb keys
  ;; left (left-2-right order)
  esc-med   (tap-hold-press $tt $ht esc @lwh-med)
  spc-nav   (tap-hold-press $tt $ht spc @lwh-nav)
  tab-mou   (tap-hold-press $tt $ht @smart-tab @lwh-mou)
  ;; right (left-2-right order)
  ret-sym   (tap-hold-press $tt $ht XX  @lwh-sym)
  ret-sym-r (tap-hold-press $tt $ht XX  @lwh-sym-r)
  bks-num   (tap-hold-press $st $ht bks @lwh-num)
  del-fun   (tap-hold-press $tt $ht del @lwh-fun)
;; this was an expiriment. decided against it, doesn't add much in COLEMAK_DH
;;  e-fun     (tap-hold-press $tt $ht e   @lwh-fun)
  ;;
)

#|
UNICODE section
have to resort to Unicode entry since many symbols in Cyrillic layout
are mapped to letters
|#
(defalias
  ;; doesn't auto-repeat
  lparen (macro S-9)
  rparen (macro S-0)
  ;; {[()]}
  lbrace (unicode {)
  rbrace (unicode })
  lbrack (unicode [)
  rbrack (unicode ])
  ;; extra
  grave  (unicode `)
  tilde  (unicode ~)
  slash  (unicode /)
  pipe   (unicode |)
  backsl (unicode \)
;;
  colon  (unicode :)
  semicl (unicode ;)
;;
  plus   (unicode +)
  equal  (unicode =)
  minus  (unicode -)
  unders (unicode _)
;;
  dot    (unicode .)
  comma  (unicode ,)
  q-mark (unicode ?)
;;
  at     (unicode @)
  hash   (unicode #)
  dollar (unicode $)
  euro   (unicode €)
  percen (unicode %)
  caret  (unicode ^)
  ampers (unicode &)
;;
  apo    (unicode ')
;;
  gt     (unicode >)
  lt     (unicode <)
  ;;
)

(defalias
  ;; aliases for secondary layers:
  ;;   no-key / permanent layer-switch
  ;; EXPLANATION:
  ;; first tap => no action (XX)
  ;; you need to TAP the key TWICE, tiemout=200ms,
  ;; to permanently SWITCH to the layer wanted
  n-tap (tap-dance $tt (XX @lsw-tap))
  n-qwe (tap-dance $tt (XX @lsw-qwe))
  n-bas (tap-dance $tt (XX @lsw-bas))

  ;; aliases for COPY/PASTE/etc (macro so norepeat)
  copy  (macro C-ins)
  paste (macro S-ins)
  cut   (macro S-del)
  undo  (macro C-z)
  redo  (macro C-y)

  ;; symbols to be handied by OS
  ;; this references Fake-keys defined above
  s-eml (on-press-fakekey fake-hyper-a tap)
  s-btc (on-press-fakekey fake-hyper-b tap)
  s-eur (on-press-fakekey fake-hyper-c tap)
  s-tm  (on-press-fakekey fake-hyper-d tap)
  s-hyE (on-press-fakekey fake-hyper-e tap)
  s-hyF (on-press-fakekey fake-hyper-f tap)
  s-hyG (on-press-fakekey fake-hyper-g tap)
  s-hyH (on-press-fakekey fake-hyper-h tap)
  s-hyI (on-press-fakekey fake-hyper-i tap)
  s-hyJ (on-press-fakekey fake-hyper-j tap)
  s-hyK (on-press-fakekey fake-hyper-k tap)

  ;; caps-word(for 3 sec) or caps
;;  capw    (tap-hold-press $tt $ht (caps-word 3000) caps)
  capw  (caps-word 3000)
)

;; U_BAS: Chords for home row and more:
(defchords bas-chords 80
  ;; b + j = caps-word (two shifts), then caps
  (kb kj) @capw
  ;; z+/ = BUTTON layes only for the hext tap
  (kz k/) (one-shot 1000 (layer-while-held U_BUTTON))
  ;; switch to Russian (it's on a timeout so no need to define the reverse key)
  (kd kh) @rus
  ;;
  ;; all keys are mapped so that it's easy to create new chords
  ;; left half
  (kq            ) q
  (   kw         ) w
  (      kf      ) f
  (         kp   ) p
  (            kb) b
  ;;
  (ka            ) a
  (   kr         ) r
  (      ks      ) s
  (         kt   ) t
  (            kg) g
  ;;
  (kz            ) z
  (   kx         ) x
  (      kc      ) c
  (         kd   ) d
  (            kv) v
  ;; Undo/Cut/Copy/Paste
  (kz kx         ) @undo
  (   kx kc      ) @cut
  (      kc kd   ) @copy
  (         kd kv) @paste
  ;;
  ;; f+p = vim command
  (kf kp) (macro esc @colon)
  ;; w+f = vim save
  (kw kf) (macro esc @colon w ret)
  ;; right half
  (kj            ) j
  (   kl         ) l
  (      ku      ) u
  (         ky   ) y
  (            k') apo
  ;;
  (km            ) m
  (   kn         ) n
  (      ke      ) e
  (         ki   ) i
  (            ko) o
  ;;
  (kk            ) k
  (   kh         ) h
  (      k,      ) comm
  (         k.   ) .
  (            k/) /
  ;;
  ;; u + y = enter, since the "real" enter is disabled
  (ku ky) ret
  ;; , . / are chords so that they work both in English and in Russian
  (kh k,) ,
  (k, k.) .
  (k. k/) @q-mark
)
(defalias
  ;; left half
  ;; first row
  ;; here I'm using fork to ignore keys if any of the HRMs of the same side are actively depressed
  bas-q   (fork (chord bas-chords kq) XX (lalt lctl lmet))
  bas-w   (fork (chord bas-chords kw) XX (lalt lctl lmet))
  bas-f   (fork (chord bas-chords kf) XX (lalt lctl lmet))
  bas-p   (fork (chord bas-chords kp) XX (lalt lctl lmet))
  bas-b   (fork (chord bas-chords kb) XX (lalt lctl lmet))
  ;;second row
  ;; prevent rolls from affecting neighbouring keys (as defined in defsrc)
  ;; so a/s/d/f input results in this:
  bas-a         (tap-hold-press $tt $ht (chord bas-chords ka) lmet)
  bas-r   (fork (tap-hold-press $tt $ht (chord bas-chords kr) lalt) f18 (lctl))
  bas-s   (fork (tap-hold-press $tt $ht (chord bas-chords ks) lctl) XX  (lalt))
  bas-t   (fork (tap-hold-press $tt $ht (chord bas-chords kt) lsft) XX  (lctl))
  bas-g   (fork (chord bas-chords kg) XX (lalt lctl lmet))
  ;; third row
  ;; keys z/x/c/d/v for undo/cut/copy/paste
  bas-z   (fork (chord bas-chords kz) XX (lalt lctl lmet))
  bas-x   (fork (chord bas-chords kx) XX (lalt lctl lmet))
  bas-c   (fork (chord bas-chords kc) XX (lalt lctl lmet))
  bas-d   (fork (chord bas-chords kd) XX (lalt lctl lmet))
  bas-v   (fork (chord bas-chords kv) XX (lalt lctl lmet))
  ;; thumbs
  ;; bas-bks (chord bas-chords k-bks)
;;  bas-bks @bks-med
;;  bas-esc @esc-nav
;;  bas-tab @tab-mou
  bas-bks @esc-med
  bas-del @spc-nav
  bas-end @tab-mou
  ;; right half
  ;; first row
  bas-j   (fork (chord bas-chords kj) XX (ralt rctl rmet))
  bas-l   (fork (chord bas-chords kl) XX (ralt rctl rmet))
  bas-u   (fork (chord bas-chords ku) XX (ralt rctl rmet))
  bas-y   (fork (chord bas-chords ky) XX (ralt rctl rmet))
  bas-'   (fork (chord bas-chords k') XX (ralt rctl rmet))
  ;; second row
  bas-m   (fork (chord bas-chords km) XX (lalt rctl rmet))
  bas-n   (fork (tap-hold-press $tt $ht (chord bas-chords kn) rsft) XX  (rctl))
  bas-e   (fork (tap-hold-press $tt $ht (chord bas-chords ke) rctl) XX  (ralt))
  bas-i   (fork (tap-hold-press $tt $ht (chord bas-chords ki) ralt) f18 (rmet))
  bas-o         (tap-hold-press $tt $ht (chord bas-chords ko) rmet)
  ;; third row
  bas-k   (fork (chord bas-chords kk) XX (ralt rctl rmet))
  bas-h   (fork (chord bas-chords kh) XX (ralt rctl rmet))
  bas-,   (fork (chord bas-chords k,) XX (ralt rctl rmet))
  bas-.   (fork (chord bas-chords k.) XX (ralt rctl rmet))
  bas-/   (fork (chord bas-chords k/) XX (ralt rctl rmet))
  ;; thumbs
  bas-pgd @ret-sym
  bas-ret @bks-num
  bas-spc @del-fun
;;  bas-spc @e-fun
)

#|
 main layout: Colemac-DH with extra keys:
 home-row modifiers:
  MACS/WACS
 extra:
   z or / => button layer
   x or . => right alt

 thumb special layer mappings - left side:
 (left-to-right):

 esc       => media
 space     => navigation
 tab       => mouse

 thumb special layer mappings - right side:
 (left-to-right):

 backspace => symbols
 enter     => numbers
 delete    => functions
|#

(deflayer U_BASE
  ;; left
  @bas-q  @bas-w  @bas-f  @bas-p  @bas-b
  @bas-a  @bas-r  @bas-s  @bas-t  @bas-g
  @bas-z  @bas-x  @bas-c  @bas-d  @bas-v
  @bas-bks        @bas-del        @bas-end
  ;; right
  @bas-j  @bas-l  @bas-u  @bas-y  @bas-'
  @bas-m  @bas-n  @bas-e  @bas-i  @bas-o
  @bas-k  @bas-h  @bas-,  @bas-.  @bas-/
  @bas-pgd        @bas-ret        @bas-spc
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

;; we use QWERTY layer with home-row modifiers and button+right alt
;; to allow proper Cyrillic mapping
;;
;; here are some hacks:
;; ъ is double-tapped ь
;; ё is double-tapped е
;; э is triple-tapped е
(defalias
  ;; cyrillic е/э/ё
  cyr-eee  (tap-dance $tt (i apo grv))
  ;; cyrillic ь/ъ
  cyr-soft (tap-dance $tt (m ]))
  ;; cyrillic   ф/х
  cyr-fh   (tap-dance $tt (o [))
  ;; for {[()]} -- TBD
)

;; U_QWERTY:
(defchords qwe-chords 80
  ;; f + j = caps-word (two shifts)
;;  (qt qy) @capw
  ;;
  (qz q/) (one-shot 1000 (layer-while-held U_BUTTON))
  ;;
  (qv qm) @eng
  ;; left half
  (qq            ) q
  (   qw         ) w
  (      qe      ) e
  (         qr   ) r
  (            qt) t
  ;;
  (qa            ) a
  (   qs         ) s
  (      qd      ) d
  (         qf   ) f
  (            qg) g
  ;;
  (qz            ) z
  (   qx         ) x
  (      qc      ) c
  (         qv   ) v
  (            qb) b
  ;; Undo/Cut/Copy/Paste
  (qz qx         ) @undo
  (   qx qc      ) @cut
  (      qc qv   ) @copy
  (         qv qb) @paste
  ;; right half
  (qy            ) y
  (   qu         ) u
  (      qi      ) @cyr-eee
  (         qo   ) @cyr-fh
  (            qp) p
  ;;
  (qh            ) h
  (   qj         ) j
  (      qk      ) k
  (         ql   ) l
  (            q;) ;
  ;;
  (qn            ) n
  (   qm         ) @cyr-soft
  (      q,      ) comm
  (         q.   ) .
  (            q/) @slash
  ;;
;;  (qu qi) S-2
  (qi qo) ret
  (qm q,) @comma
  (q, q.) @dot
  (q. q/) @q-mark
)
(defalias
  ;; left half
  ;; only output if none of the opposing-hand HRMs are depressed
  ;; first row
;;  qwe-q   (chord qwe-chords qq)
  qwe-q   (fork (chord qwe-chords qq) XX (lalt lctl lmet))
  qwe-w   (fork (chord qwe-chords qw) XX (lalt lctl lmet))
  qwe-e   (fork (chord qwe-chords qe) XX (lalt lctl lmet))
  qwe-r   (fork (chord qwe-chords qr) XX (lalt lctl lmet))
  qwe-t   (fork (chord qwe-chords qt) XX (lalt lctl lmet))
  ;; second row
  qwe-a         (tap-hold-press $tt $ht (chord qwe-chords qa) lmet)
  qwe-s   (fork (tap-hold-press $tt $ht (chord qwe-chords qs) lalt) f18 (lmet))
  qwe-d   (fork (tap-hold-press $tt $ht (chord qwe-chords qd) lctl) XX  (lctl))
  qwe-f   (fork (tap-hold-press $tt $ht (chord qwe-chords qf) lsft) XX  (lctl))
  qwe-g   (fork (chord qwe-chords qg) XX (lalt rctl lmet))
  ;; third row
  qwe-z   (fork (chord qwe-chords qz) XX (lalt lctl lmet))
  qwe-x   (fork (chord qwe-chords qx) XX (lalt lctl lmet))
  qwe-c   (fork (chord qwe-chords qc) XX (lalt lctl lmet))
  qwe-v   (fork (chord qwe-chords qv) XX (lalt lctl lmet))
  qwe-b   (fork (chord qwe-chords qb) XX (lalt lctl lmet))
  ;; thumbs
  qwe-bks @esc-med
  qwe-del @spc-nav
  qwe-end @tab-mou
  ;; right half(chord qwe-chords qz)
  ;; first row
  qwe-y   (fork (chord qwe-chords qy) XX (ralt rctl rmet))
  qwe-u   (fork (chord qwe-chords qu) XX (ralt rctl rmet))
  qwe-i   (fork (chord qwe-chords qi) XX (ralt rctl rmet))
  qwe-o   (fork (chord qwe-chords qo) XX (ralt rctl rmet))
  qwe-p   (fork (chord qwe-chords qp) XX (ralt rctl rmet))
  ;; second row
  qwe-h   (fork (chord qwe-chords qh) XX (lalt rctl rmet))
  qwe-j   (fork (tap-hold-press $tt $ht (chord qwe-chords qj) rsft) XX  (rctl))
  qwe-k   (fork (tap-hold-press $tt $ht (chord qwe-chords qk) rctl) XX  (lalt))
  qwe-l   (fork (tap-hold-press $tt $ht (chord qwe-chords ql) lalt) f18 (rmet))
  qwe-;         (tap-hold-press $tt $ht (chord qwe-chords q;) rmet)
  ;; third row
  qwe-n   (fork (chord qwe-chords qn) XX (ralt rctl rmet))
  qwe-m   (fork (chord qwe-chords qm) XX (ralt rctl rmet))
  qwe-,   (fork (chord qwe-chords q,) XX (ralt rctl rmet))
  qwe-.   (fork (chord qwe-chords q.) XX (ralt rctl rmet))
  qwe-/   (fork (chord qwe-chords q/) XX (ralt rctl rmet))
  ;; thumbs
  qwe-pgd @ret-sym-r
  qwe-ret @bks-num
  qwe-spc @del-fun
)

(deflayer U_QWERTY
  ;; left
  @qwe-q  @qwe-w  @qwe-e  @qwe-r  @qwe-t
  @qwe-a  @qwe-s  @qwe-d  @qwe-f  @qwe-g
  @qwe-z  @qwe-x  @qwe-c  @qwe-v  @qwe-b
  @qwe-bks        @qwe-del        @qwe-end
  ;; right
  @qwe-y  @qwe-u  @qwe-i  @qwe-o  @qwe-p
  @qwe-h  @qwe-j  @qwe-k  @qwe-l  @qwe-;
  @qwe-n  @qwe-m  @qwe-,  @qwe-.  @qwe-/
  @qwe-pgd        @qwe-ret        @qwe-spc
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; experimental layer for Russian
;; based on Leonov's work here: https://habr.com/ru/articles/717912/
(deflayer U_RUS_LEO
  ;; left
;;цч к  л  б  й
  w  r  k  ,  q
;;жз в  н  т  д
  ;  d  y  n  l
;;х  п  р  м  г
  [  g  h  v  u
  bks        del        end
  ;; right
;;щх ы  я  э  ф
  o  s  z  '  z
;;ьъ а  о  е  с
  m  j  j  t  c
;;шё и  у  ю  /
  i  b  ,  .  /
  @qwe-pgd        @qwe-ret        @qwe-spc
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deflayer U_TAP
  ;; left
  q       w       f       p       b
  a       r       s       t       g
  z       x       c       d       v
  @esc-med        spc             tab
  ;; right
  j       l       u       y       apo
  m       n       e       i       o
  k       h       ,       .       /
  ent             bspc            del
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

(deflayer U_NUM
  ;; left
  kp-     7       8       9       kp+
  @colon  4       5       6       eql
  @dollar 1       2       3       kp/
  @dot            0               -
  ;; right
  XX      XX      XX      XX      XX
  ret     sft     ctl     alt     met
  met     bspc    tab     caps    @backsl
  XX              XX              XX
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

 ;; this is no longer just shifted S_NUM
(deflayer U_SYM
  ;; left
  S-1     S-2     S-3     S-4     S-5
  S-scln  S-`     S-apo   S-eql   S-\
  scln    `       apo     eql     \
  S-9             S-0             S--
  ;; right
  S-6     S-7     S-8     S-9     S-0
  XX      lsft    lctl    lalt    lmet
  XX      bspc    tab     caps    \
  XX              XX              XX
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

;; this is no longer just shifted S_NUM
(deflayer U_SYM_RUS
  ;; left
  S-1     @at     @hash   @dollar @percen
  @colon  @tilde  S-2     @plus   @pipe
  @semicl @grave  @apo    @equal  @backsl
  @lparen         @rparen         @unders
  ;; right
  @caret  @ampers S-8     S-9     S-0
  XX      lsft    lctl    lalt    lmet
  XX      bspc    tab     caps    @backsl
  XX              XX              XX
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

(deflayer U_FUN
  ;; left
  f12     f7      f8      f9      prtsc
  f11     f4      f5      f6      slck
  f10     f1      f2      f3      pause
  comp            spc             tab
  ;; right
  XX      @n-bas  @n-qwe  @n-tap  XX
  ret     sft     ctl     alt     met
  bspc    bspc    tab     caps    @backsl
  XX              XX              XX
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl

)

(defalias
  ;; live config reload
  nav-q lrld
  ;; M+C+A key defined here
;;  nav-d (multi rmet rctl lalt)
)
(deflayer U_NAV
  ;; left
  ;; added keys ([{}]) for VIM navigation
  @nav-q  @n-tap  @n-qwe  @n-bas  @lbrace
  met     alt     ctl     sft     @lbrack
  XX      XX      left    right   @lparen
  XX              XX              XX
  ;; right
  @rbrace home    up      end     pgup
  @rbrack left    down    right   pgdn
  @rparen XX      XX      XX      XX
  XX              del             ins
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

(deflayer U_BUTTON
  ;; left
  @s-eml  @s-btc  @s-eur  @s-tm   @s-hyE
  met     alt     ctl     sft     @s-hyF
  @s-hyG  @s-hyH  @s-hyI  @s-hyJ  @s-hyK
  mmtp            mltp            mrtp
  ;; right
  @redo   @paste  @cut    @copy   @undo
  XX      sft     ctl     alt     met
  @redo   @paste  @cut    @copy   @undo
  mrtp            mltp            mmtp
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

;; some aliases for the mouse
(defalias
  mwu (mwheel-up 500 120)
  mwd (mwheel-down 500 120)
  mwl (mwheel-left 50 120)
  mwr (mwheel-right 50 120)

  ms↑ (movemouse-up 1 1)
  ms← (movemouse-left 1 1)
  ms↓ (movemouse-down 1 1)
  ms→ (movemouse-right 1 1)

  ma↑ (movemouse-accel-up 1 1000 1 5)
  ma← (movemouse-accel-left 1 1000 1 5)
  ma↓ (movemouse-accel-down 1 1000 1 5)
  ma→ (movemouse-accel-right 1 1000 1 5)
)

(deflayer U_MOUSE
  ;; left half
  XX      @n-tap  @n-qwe  @n-bas  XX
  met     alt     ctl     sft     XX
  XX      XX      XX      XX      del
  ;; thumbs
  XX              XX              XX
  ;; right half
  @eng    @mwl    @ma↑    @mwr    @mwu
  @rus    @ma←    @ma↓    @ma→    @mwd
  XX      XX      XX      XX      XX
  ;; thumbs - r/l/m mouse tapt (as opposed to clicks)
  mrtp            mltp            mmtp
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

;; this tells VoiceMeeter to
;; turn mic passthrough to headphones
(deffakekeys
  micon  (cmd vmcli Strip[1].Gate=3   Strip[1].A1=1 Strip[1].B2=0)
  micoff (cmd vmcli Strip[1].Gate=7.4 Strip[1].A1=0 Strip[1].B2=1)
)
;; ON  when the key is pressed
;; OFF when it's released
(defalias
  miconoff (multi
    (on-press-fakekey   micon  tap)
    (on-release-fakekey micoff tap)
  )
  ;; reset sound system
  sndrst (cmd C:\PROGRA~2\VB\VOICEM~1\VOICEM~4.EXE -R)
  ;; send commands to VoiceMeeter
  mute   (cmd vmcli Bus[0].Mute=1)
  unmute (cmd vmcli Bus[0].Mute=0)
  volu   (cmd vmcli Bus[0].Gain+=1)
  vold   (cmd vmcli Bus[0].Gain-=1)
)
(deflayer U_MEDIA
  ;; left
  ;; since I use VoiceMeeter for all sound,
  ;;instead of volu/vold I send commands to it.
  @sndrst @n-tap  @n-qwe  @n-bas  XX
  XX      XX      XX      XX      XX
  XX      XX      XX      XX      XX
  bks             XX              XX
  ;; right
  XX      XX      @volu   XX      XX
  XX      prev    @vold   next    @miconoff
  XX      XX      XX      XX      XX
  @unmute         pp              @mute
  ;; extra keys - not actually used, needed to intercept events
  @lwh-ctl
)

(deflayer U_CTL
  ;; right half
  XX      XX      XX      XX      XX
  XX      XX      XX      XX      XX
  XX      XX      C-ins   S-ins   XX
  ;; thumbs
  XX              XX              XX
  ;; left half
  XX      XX      XX      XX      XX
  XX      XX      XX      XX      XX
  XX      XX      XX      XX      XX
  ;; thumbs
  XX              XX              XX
  ;; extra keys - not actually used, needed to intercept events
  XX
)
